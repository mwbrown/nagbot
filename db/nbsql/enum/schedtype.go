// Code generated by gnorm, DO NOT EDIT!

package enum

import (
	"database/sql/driver"
	"errors"

	"github.com/mwbrown/nagbot/db/nbsql"
)

// SchedType is the 'sched_type' enum type from schema 'Public'.
type SchedType uint16

const (
	// UnknownSchedType defines an invalid SchedType.
	UnknownSchedType SchedType = 0
	OneshotSchedType SchedType = 1

	IntervalSchedType SchedType = 2

	WeeklySchedType SchedType = 3

	MonthDaySchedType SchedType = 4

	MonthWeekdaySchedType SchedType = 5

	AnnualSchedType SchedType = 6
)

// String returns the string value of the SchedType.
func (e SchedType) String() string {
	switch e {
	case OneshotSchedType:
		return "Oneshot"
	case IntervalSchedType:
		return "Interval"
	case WeeklySchedType:
		return "Weekly"
	case MonthDaySchedType:
		return "MonthDay"
	case MonthWeekdaySchedType:
		return "MonthWeekday"
	case AnnualSchedType:
		return "Annual"
	default:
		return "UnknownSchedType"
	}
}

// MarshalText marshals SchedType into text.
func (e SchedType) MarshalText() ([]byte, error) {
	return []byte(e.String()), nil
}

// UnmarshalText unmarshals SchedType from text.
func (e *SchedType) UnmarshalText(text []byte) error {
	val, err := ParseSchedType(string(text))
	if err != nil {
		return err
	}
	*e = val
	return nil
}

// ParseSchedType converts s into a SchedType if it is a valid
// stringified value of SchedType.
func ParseSchedType(s string) (SchedType, error) {
	switch s {
	case "Oneshot":
		return OneshotSchedType, nil
	case "Interval":
		return IntervalSchedType, nil
	case "Weekly":
		return WeeklySchedType, nil
	case "MonthDay":
		return MonthDaySchedType, nil
	case "MonthWeekday":
		return MonthWeekdaySchedType, nil
	case "Annual":
		return AnnualSchedType, nil
	default:
		return UnknownSchedType, errors.New("invalid SchedType")
	}
}

// Value satisfies the sql/driver.Valuer interface for SchedType.
func (e SchedType) Value() (driver.Value, error) {
	return e.String(), nil
}

// Scan satisfies the database/sql.Scanner interface for SchedType.
func (e *SchedType) Scan(src interface{}) error {
	buf, ok := src.([]byte)
	if !ok {
		return errors.New("invalid SchedType")
	}

	return e.UnmarshalText(buf)
}

// SchedTypeField is a component that returns a nbsql.WhereClause that contains a
// comparison based on its field and a strongly typed value.
type SchedTypeField string

// Equals returns a nbsql.WhereClause for this field.
func (f SchedTypeField) Equals(v SchedType) nbsql.WhereClause {
	return nbsql.Where{
		Field: string(f),
		Comp:  nbsql.CompEqual,
		Value: v,
	}
}

// GreaterThan returns a nbsql.WhereClause for this field.
func (f SchedTypeField) GreaterThan(v SchedType) nbsql.WhereClause {
	return nbsql.Where{
		Field: string(f),
		Comp:  nbsql.CompGreater,
		Value: v,
	}
}

// LessThan returns a nbsql.WhereClause for this field.
func (f SchedTypeField) LessThan(v SchedType) nbsql.WhereClause {
	return nbsql.Where{
		Field: string(f),
		Comp:  nbsql.CompEqual,
		Value: v,
	}
}

// GreaterOrEqual returns a nbsql.WhereClause for this field.
func (f SchedTypeField) GreaterOrEqual(v SchedType) nbsql.WhereClause {
	return nbsql.Where{
		Field: string(f),
		Comp:  nbsql.CompGTE,
		Value: v,
	}
}

// LessOrEqual returns a nbsql.WhereClause for this field.
func (f SchedTypeField) LessOrEqual(v SchedType) nbsql.WhereClause {
	return nbsql.Where{
		Field: string(f),
		Comp:  nbsql.CompLTE,
		Value: v,
	}
}

// NotEqual returns a nbsql.WhereClause for this field.
func (f SchedTypeField) NotEqual(v SchedType) nbsql.WhereClause {
	return nbsql.Where{
		Field: string(f),
		Comp:  nbsql.CompNE,
		Value: v,
	}
}

// In returns a nbsql.WhereClause for this field.
func (f SchedTypeField) In(vals []SchedType) nbsql.WhereClause {
	values := make([]interface{}, len(vals))
	for x := range vals {
		values[x] = vals[x]
	}
	return nbsql.InClause{
		Field: string(f),
		Vals:  values,
	}
}
