// Code generated by gnorm, DO NOT EDIT!

package {{.Params.RootPkg}}

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"strconv"
	"strings"
)

// DB is the common interface for database operations.
//
// This should work with database/sql.DB and database/sql.Tx.
type DB interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}

// Jsonb is a wrapper for map[string]interface{} for storing json into postgres
type Jsonb map[string]interface{}

// Value marshals the json into the database
func (j Jsonb) Value() (driver.Value, error) {
	return json.Marshal(j)
}

// Scan Unmarshalls the bytes[] back into a Jsonb object
func (j *Jsonb) Scan(src interface{}) error {
	source, ok := src.([]byte)
	if !ok {
		return errors.New("Type assertion .([]byte) failed")
	}

	var i interface{}
	err := json.Unmarshal(source, &i)
	if err != nil {
		return err
	}

	if i == nil {
		return nil
	}

	*j, ok = i.(map[string]interface{})
	if !ok {
		return errors.New("reading from DB into Jsonb, failed to convert to map[string]interface{}")
	}

	return nil
}

// UnOrdered is a convenience value to make it clear you're not sorting a query.
var UnOrdered = OrderBy{}

// OrderByDesc returns a sort order descending by the given field.
func OrderByDesc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderDesc,
	}
}

// OrderByAsc returns a sort order ascending by the given field.
func OrderByAsc(field string) OrderBy {
	return OrderBy{
		Field: field,
		Order: OrderAsc,
	}
}

// OrderBy indicates how rows should be sorted.
type OrderBy struct {
	Field string
	Order SortOrder
}

func (o OrderBy) String() string {
	if o.Order == OrderNone {
		return ""
	}
	return " ORDER BY " + o.Field + " " + o.Order.String() + " "
}

// SortOrder defines how to order rows returned.
type SortOrder int

// Defined sort orders for not sorted, descending and ascending.
const (
	OrderNone SortOrder = iota
	OrderDesc
	OrderAsc
)

// String returns the sql string representation of this sort order.
func (s SortOrder) String() string {
	switch s {
	case OrderDesc:
		return "DESC"
	case OrderAsc:
		return "ASC"
	}
	return ""
}

// WhereClause has a String function should return a properly formatted where
// clause (not including the WHERE) for positional arguments starting at idx.
type WhereClause interface {
	String(idx *int) string
	Values() []interface{}
}

// Comparison is used by WhereClauses to create valid sql.
type Comparison string

// Comparison types.
const (
	CompEqual   Comparison = " = "
	CompGreater Comparison = " > "
	CompLess    Comparison = " < "
	CompGTE     Comparison = " >= "
	CompLTE     Comparison = " <= "
	CompNE      Comparison = " <> "
)

type Where struct {
	Field string
	Comp  Comparison
	Value interface{}
}

func (w Where) String(idx *int) string {
	ret := w.Field + string(w.Comp) + "$" + strconv.Itoa(*idx)
	(*idx)++
	return ret
}

func (w Where) Values() []interface{} {
	return []interface{}{w.Value}
}

// NullClause is a clause that checks for a column being null or not.
type NullClause struct {
	Field string
	Null  bool
}

func (n NullClause) String(idx *int) string {
	if n.Null {
		return n.Field + " IS NULL "
	}
	return n.Field + " IS NOT NULL "
}

func (n NullClause) Values() []interface{} {
	return []interface{}{}
}

// AndClause returns a WhereClause that serializes to the AND
// of all the given where clauses.
func AndClause(wheres ...WhereClause) WhereClause {
	return andClause(wheres)
}

type andClause []WhereClause

func (a andClause) String(idx *int) string {
	wheres := make([]string, len(a))
	for x := 0; x < len(a); x++ {
		wheres[x] = a[x].String(idx)
	}
	return strings.Join(wheres, " AND ")
}

func (a andClause) Values() []interface{} {
	vals := make([]interface{}, 0, len(a))
	for x := 0; x < len(a); x++ {
		vals = append(vals, a[x].Values()...)
	}
	return vals
}

// OrClause returns a WhereClause that serializes to the OR
// of all the given where clauses.
func OrClause(wheres ...WhereClause) WhereClause {
	return orClause(wheres)
}

type orClause []WhereClause

func (o orClause) String(idx *int) string {
	wheres := make([]string, len(o))
	for x := 0; x < len(wheres); x++ {
		wheres[x] = o[x].String(idx)
	}
	return strings.Join(wheres, " OR ")
}

func (o orClause) Values() []interface{} {
	vals := make([]interface{}, len(o))
	for x := 0; x < len(o); x++ {
		vals = append(vals, o[x].Values()...)
	}
	return vals
}

// InClause takes a slice of values that it matches against.
type InClause struct {
	Field  string
	Vals []interface{}
}

func (in InClause) String(idx *int) string {
	ret := in.Field + " in ("
	for x := range in.Vals {
		if x != 0 {
			ret += ", "
		}
		ret += "$" + strconv.Itoa(*idx)
		(*idx)++
	}
	ret += ")"
	return ret
}

func (in InClause) Values() []interface{} {
	return in.Vals
}